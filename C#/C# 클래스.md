## 클래스
객체지향 프로그래밍(Object Oriented Programming)은 코드를 *객체*로 표현하고자 하는 프로그래밍 패러다임  
클래스: 객체(=인스턴스)의 속성과 기능을 정의하나 실체가 없는 청사진 역할  
코드 관점에서 보면 또 하나의 *복합 데이터 형식*이기도 함  
<br/>
필드: 클래스 내 선언된 변수  
메소드: 특정 기능을 구현하고자 정의된 코드들의 집합으로 함수와 비슷  
멤버: 필드와 메소드, 프로퍼티, 이벤트 등 클래스 내 선언된 요소들을 일컫는 말 
<br/>
### 생성자
클래스는 복합 데이터 형식이고, 복합 데이터 형식은 *참조 형식*으로 사용해야 함    
힙에 실제 객체를 생성할 *생성자*가 필요!  
```
ex> Doggy dok = new Doggy();  
dok은 그 자체에 메모리가 할당되는게 아니고 객체의 *주소*를 가리킴  
그래서 new 연산자와 기본 생성자 Doggy로 객체 *생성*  
```
### 기본 생성자
형식은 클래스이름()  
컴파일러에서 자동으로 클래스이름과 같은 생성자를 만듦  
생성자를 하나라도 직접 정의하면 C# 컴파일러는 이러한 기본 생성자를 만들지 않음    
<br/>
### 종료자
형식은 ~클래스이름()  
객체를 소멸시킴. 오버로딩, 호출, 매개변수, 한정자 사용 X  
사용자에게 직접 사용을 권장하지 않는 이유  
1. CLR의 가비지 컬렉터가 언제 작동할지 예측할 수 없음  
2. 클래스의 조상을 찾아 객체로부터 상속받은 Finalize() 메소드를 호출해야 해서 프로그램 성능 낮아짐  
3. 사람보다는 가비지 컬렉터가 소멸을 더 잘 처리함  
<br/>
### 정적 필드
인스턴스에 소속된 필드 vs 클래스에 소속된 필드(static) ?  
한 프로그램에 서로 같은 인스턴스는 여러개가 존재할 수 있으나 서로 같은 클래스는 존재할 수 없음  
그래서 어떤 필드가 클래스에 소속된다는 것 = 해당 필드가 프로그램 전체에서 유일하게 존재한다는 것!  
*static*이 이를 지정하는 한정자, 한정되지 않은 필드는 자동으로 인스턴스에 소속  
필드를 선언할 때 앞에 static을 붙여 한정  
### 정적 메소드
정적 메소드는 인스턴스를 만들지 않더라도 호출 가능  
이와 반대되는 비정적 메소드 = *인스턴스 메소드*, 인스턴스를 생성해야만 호출 가능  
메소드를 선언할 때 앞에 static을 붙여 한정  
<br/>
보통 객체 내부 데이터를 이용해야 하면 인스턴스 메소드를 선언, 아니면 정적 메소드로 한정한다.  
### 얕은 복사 vs 깊은 복사
얕은 복사: 데이터를 가져와 새로운 메모리에 할당하는 방식이 아닌 데이터를 참조하는 형식의 복사 ( 실제 데이터 1개 )    
깊은 복사: 데이터를 가져와 새로운 메모리에 할당하는 방식을 취하는 형식의 복사 ( 실제 데이터 2개 )  
클래스 = 복합 데이터 = 참조 형식 = 그냥 =으로 데이터 할당시 얕은 복사가 됨   
C#에는 이를 자동으로 구분해주는 구문이 따로 없으므로,  
객체를 힙에 새로 할당하여 멤버를 일일히 복사해넣을 구문을 직접 작성해야 함  
###this 키워드
객체 외부에서 객체의 필드나 메소드에 접근할 때 객체의 이름(변수 or 식별자)을 사용한다면,  
객체 내부에서는 자신의 필드나 메소드에 접근할 때 this 키워드 사용  
```
class Dog
{
	private string DogName; // SetName의 매개변수에 있는 DogName과 다른 클래스의 필드  

	public void SetName( string DogName ) // Dog 클래스에 선언된 필드와 다른 매개변수가 외부로부터 전달됨  
	{
		this.DogName = DogName; // this 키워드로 서로 다른 두 DogName이 명확하게 구분됨
	}
}
```
### this() 생성자
키워드 this가 객체 내부에서 클래스의 필드나 메서드를 가리켰다면,  
생성자 this()는 자기 자신의 생성자를 가리킴  
