## 클래스
객체지향 프로그래밍(Object Oriented Programming)은 코드를 *객체*로 표현하고자 하는 프로그래밍 패러다임  
클래스: 객체(=인스턴스)의 속성과 기능을 정의하나 실체가 없는 청사진 역할  
코드 관점에서 보면 또 하나의 *복합 데이터 형식*이기도 함  
<br/>
필드: 클래스 내 선언된 변수  
메소드: 특정 기능을 구현하고자 정의된 코드들의 집합으로 함수와 비슷  
멤버: 필드와 메소드, 프로퍼티, 이벤트 등 클래스 내 선언된 요소들을 일컫는 말 
<br/>
### 생성자
클래스는 복합 데이터 형식이고, 복합 데이터 형식은 *참조 형식*으로 사용해야 함    
힙에 실제 객체를 생성할 *생성자*가 필요!  
```
ex> Doggy dok = new Doggy();  
dok은 그 자체에 메모리가 할당되는게 아니고 객체의 *주소*를 가리킴  
그래서 new 연산자와 기본 생성자 Doggy로 객체 *생성*  
```
### 기본 생성자
형식은 클래스이름()  
컴파일러에서 자동으로 클래스이름과 같은 생성자를 만듦  
생성자를 하나라도 직접 정의하면 C# 컴파일러는 이러한 기본 생성자를 만들지 않음    
<br/>
### 종료자
형식은 ~클래스이름()  
객체를 소멸시킴. 오버로딩, 호출, 매개변수, 한정자 사용 X  
사용자에게 직접 사용을 권장하지 않는 이유  
1. CLR의 가비지 컬렉터가 언제 작동할지 예측할 수 없음  
2. 클래스의 조상을 찾아 객체로부터 상속받은 Finalize() 메소드를 호출해야 해서 프로그램 성능 낮아짐  
3. 사람보다는 가비지 컬렉터가 소멸을 더 잘 처리함  
<br/>
### 정적 필드
인스턴스에 소속된 필드 vs 클래스에 소속된 필드(static) ?  
한 프로그램에 서로 같은 인스턴스는 여러개가 존재할 수 있으나 서로 같은 클래스는 존재할 수 없음  
그래서 어떤 필드가 클래스에 소속된다는 것 = 해당 필드가 프로그램 전체에서 유일하게 존재한다는 것!  
*static*이 이를 지정하는 한정자, 한정되지 않은 필드는 자동으로 인스턴스에 소속  
필드를 선언할 때 앞에 static을 붙여 한정  
### 정적 메소드
정적 메소드는 인스턴스를 만들지 않더라도 호출 가능  
이와 반대되는 비정적 메소드 = *인스턴스 메소드*, 인스턴스를 생성해야만 호출 가능  
메소드를 선언할 때 앞에 static을 붙여 한정  
<br/>
보통 객체 내부 데이터를 이용해야 하면 인스턴스 메소드를 선언, 아니면 정적 메소드로 한정한다.  
### 얕은 복사 vs 깊은 복사
얕은 복사: 데이터를 가져와 새로운 메모리에 할당하는 방식이 아닌 데이터를 참조하는 형식의 복사 ( 실제 데이터 1개 )    
깊은 복사: 데이터를 가져와 새로운 메모리에 할당하는 방식을 취하는 형식의 복사 ( 실제 데이터 2개 )  
클래스 = 복합 데이터 = 참조 형식 = 그냥 =으로 데이터 할당시 얕은 복사가 됨   
C#에는 이를 자동으로 구분해주는 구문이 따로 없으므로,  
객체를 힙에 새로 할당하여 멤버를 일일히 복사해넣을 구문을 직접 작성해야 함  
### this 키워드
객체 외부에서 객체의 필드나 메소드에 접근할 때 객체의 이름(변수 or 식별자)을 사용한다면,  
객체 내부에서는 자신의 필드나 메소드에 접근할 때 this 키워드 사용  
```
class Dog
{
	private string DogName; // SetName의 매개변수에 있는 DogName과 다른 클래스의 필드  

	public void SetName( string DogName ) // Dog 클래스에 선언된 필드와 다른 매개변수가 외부로부터 전달됨  
	{
		this.DogName = DogName; // this 키워드로 서로 다른 두 DogName이 명확하게 구분됨
	}
}
```
### this() 생성자
키워드 this가 객체 내부에서 자기 클래스의 필드나 메서드를 가리켰다면,  
생성자 this()는 자기의 생성자를 가리킴  
```
class MyClass
{
	int a, b, c;

	public Myclass()
	{
		this.a = 5425;
	}

	public MyClass(int b) : this() // this()는 MyClass를 호출하는 것
	{
		this.b = b;
	}
	
	public Mylass(int b, int c) : this( b ) // this( b )는 MyClass(int b)를 호출하는 것 
	{
		this.c = c;
	}
}
```
위는 오버로딩을 예시로 설명한 것임  
### 접근한정자
클래스의 멤버들을 사용자로부터 보호하고자 여섯 가지의 접근한정자를 가짐  
public, protected, private, internal, protected internal, private  
퍼블릭은 내/외부 모든 곳에서 접근 가능  
프로택티드는 파생 클래스에서는 접근 가능  
프라이베잇은 클래스의 내부에서만 접근 가능  
인터널은 같은 어셈블리에 있는 코드에서만 public으로 접근 가능  
프로택티드 인터널은 같은 어셈블리에 있는 코드에서만 protected로 접근 가능  
프라이베잇 프로택티드는 같은 어셈블리에 있는 클래스에서 상속받는 클래스 내부에서만 접근 가능  
### 상속으로 코드 재활용
방식은 아래와 같음  
```
class 기반 클래스
{
}
class 파생 클래스 : 기반 클래스
{
}
```
기반 클래스의 생성  
파생 클래스의 생성  
파생 클래스의 소멸 
기반 클래스의 소멸 순서로 작동함  
### base 키워드
기반 클래스의 생성자가 매개변수를 입력받도록 선언되어 있는 경우 base 키워드를 이용    
그러면 파생 클래스의 생성자에서 기반 클래스의 생성자로 매개변수를 넘겨줄 수 있음  
public Derived(string Nmae) : base(Name) 이런 형태  
